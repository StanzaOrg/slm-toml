defpackage toml/table:
  import core
  import collections
  import toml/value
  import toml/pair

public deftype TomlTable <: TomlValue & Seqable<KeyValue<String, TomlValue>>
public defmulti entries (t: TomlTable) -> Vector<KeyValue<String, TomlValue>>
public defmulti get (t: TomlTable, k: String) -> TomlValue
public defmulti get? (t: TomlTable, k: String) -> TomlValue|False
public defmulti insert (t: TomlTable, entry: KeyValue<String, TomlValue>) -> False

public defn TomlTable ():
  val key-indexes = HashTable<String, Int>()
  val entries = Vector<KeyValue<String, TomlValue>>()

  defn set-entry (key: String, value: TomlValue) -> False:
    val index = length(entries)
    add(entries, key => value)
    key-indexes[key] = index

  defn get-entry (key: String) -> TomlValue|False:
    val index = get?(key-indexes, key)
    match(index: Int):
      value(entries[index])
    else:
      false

  new TomlTable:
    defmethod insert (this, entry: KeyValue<String, TomlValue>) -> False:
      if contains?(key-indexes, key(entry)):
        fatal("key `%_` already exists in table" % [key(entry)])

      val components = to-tuple(split(key(entry), ".", 2))
      if length(components) == 2:
        val first-component = components[0]
        match(get-entry(first-component)):
          (first-table: TomlValue):
            match(first-table: TomlTable):
              insert(first-table, components[1] => value(entry))
            else:
              fatal("key `%_` is not a table" % [key])
          (_: False):
            val first-table = TomlTable()
            insert(first-table, components[1] => value(entry))
            set-entry(first-component, first-table)
      else:
        set-entry(key(entry), value(entry))

    defmethod get (this, key: String) -> TomlValue:
      get?(this, key) as TomlValue

    defmethod get? (this, key: String) -> TomlValue|False:
      val components = to-tuple(split(key, ".", 2))
      if length(components) == 2:
        val first-component = components[0]
        match(get-entry(first-component)):
          (first-table: TomlValue):
            match(first-table: TomlTable):
              get?(first-table, components[1])
            else:
              fatal("key `%_` is not a table" % [key])
          (_: False):
            false
      else:
        get-entry(key)

    defmethod entries (this) -> Vector<KeyValue<String, TomlValue>>:
      entries

    defmethod to-seq (this) -> Seq<KeyValue<String, TomlValue>>:
      to-seq(entries)

public defn TomlTable (pairs: Seqable<KeyValue<String, TomlValue>>):
  val table = TomlTable()
  for pair in pairs do:
    insert(table, pair)
  table

defmethod print (o: OutputStream, f: TomlTable) -> False:
  var first? = true
  defn print-kv (kv: KeyValue<String, TomlValue>) -> False:
    val print* = print when first? else lnprint
    match(value(kv): TomlTable):
      print*(o, "%_.%~" % [key(kv), value(kv)])
    else:
      print*(o, "%_ = %~" % [key(kv), value(kv)])
    first? = false
  do(print-kv, entries(f))
