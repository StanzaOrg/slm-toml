defpackage toml/parser:
  import core
  import collections
  import maybe-utils
  import toml/value
  import toml/file
  import toml/pair
  import toml/table
  import toml/utils

defstruct ParsePosition:
  offset: Int
  line: Int
  column: Int

defn ParsePosition ():
  ParsePosition(0, 1, 1)

defstruct Parser:
  content: String
  position: ParsePosition with: (setter => set-position)
  table: TomlTable

defn peek (parser: Parser) -> Maybe<Char>:
  val offset = offset(position(parser))
  val content = content(parser)
  if offset >= length(content):
    None()
  else:
    One(content[offset])

defn error (parser: Parser, msg: Printable) -> Void:
  val pos = position(parser)
  fatal("[%~:%~]: error: %~" % [line(pos), column(pos), msg])

defn error (parser: Parser, msg: String) -> Void:
  error(parser, "%_" % [msg])

defn at-end (parser: Parser) -> True|False:
  offset(position(parser)) >= length(content(parser))

defn advance (parser: Parser) -> False:
  val old-position = position(parser)
  val offset = offset(old-position)
  var line = line(old-position)
  var column = column(old-position)
  if peek(parser) == One('\n'):
    line = line + 1
    column = 1
  set-position(parser, ParsePosition(offset + 1, line, column))

defn skip-whitespace (parser: Parser) -> False:
  take-while(parser, is-whitespace)
  false

defn expect (parser: Parser, value: Char) -> False|Void:
  if peek(parser) == One(value):
    advance(parser)
  else:
    error(parser, "Expected: `%~`\nGot: `%~`" % [value, peek(parser)])

defn take-while (parser: Parser, pred: Char -> True|False) -> String:
  defn next () -> String :
    peek(parser)
      $> and-then{_, fn (c):
        if pred(c):
          advance(parser)
          One(append(String([c]), next()))
        else:
          None()
      }
      $> value-or{_, ""}
  next()

defn parse-string (parser: Parser) -> String:
  expect(parser, '"')

  val value = take-while(parser, {_ != '"'})
  expect(parser, '"')

  value

defn parse-integer (parser: Parser) -> Int:
  to-int!(take-while(parser, is-digit))

defn parse-table (parser: Parser) -> KeyValue<String, TomlTable>:
  debug("trace: parse-table")
  expect(parser, '[')
  val name = take-while(parser, is-identifier)
  if length(name) == 0:
    error(parser, "Expected table name, got: `%~`" % [peek(parser)])
  expect(parser, ']')
  expect(parser, '\n')

  val table = TomlTable()
  parse-table-inner(parser, table, false)

  name => table

defn parse-key-value (parser: Parser) -> KeyValue<String, TomlValue>:
  debug("trace: parse-key-value")
  skip-whitespace(parser)

  val key = take-while(parser, is-identifier)
  if length(key) == 0:
    error(parser, "Expected key, got: `%~`" % [peek(parser)])

  skip-whitespace(parser)
  expect(parser, '=')
  skip-whitespace(parser)

  val c = peek(parser)
  val value =
    if c == One('"'):
      parse-string(parser)
    else if c is-not None and is-digit(value!(c)):
      parse-integer(parser)
    else:
      error(parser, "Unexpected %~" % [c])

  expect(parser, '\n')

  key => value

defn parse-table-inner (parser: Parser, table: TomlTable, root?: True|False) -> False:
  debug("trace: parse-table-inner")
  label<False> break:
    while not at-end(parser):
      match(peek(parser)):
        (v: One<Char>):
          val c = value!(v)
          if c == '[':
            if not root?:
              break(false)
            else:
              insert(table, parse-table(parser))
          else if is-whitespace(c):
            skip-whitespace(parser)
          else if is-identifier(c):
            insert(table, parse-key-value(parser))
          else:
            error(parser, "Unexpected character: '%_'" % [c])
        (_):
          error(parser, "Unexpected EOF")

public defn parse-file (content: String) -> TomlFile:
  debug("trace: parse-file")
  val parser = Parser(content, ParsePosition(), TomlTable())
  parse-table-inner(parser, table(parser), true)
  TomlFile(table(parser))
