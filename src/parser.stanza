defpackage toml/parser:
  import core
  import collections
  import toml/value
  import toml/file
  import toml/pair
  import toml/table

defstruct Parser:
  content: String
  position: Int with: (setter => set-position)
  table: TomlTable

defn peek (parser: Parser) -> Maybe<Char>:
  val position = position(parser)
  val content = content(parser)
  if position >= length(content):
    None()
  else:
    One(content[position])

defn at-end (parser: Parser) -> True|False:
  position(parser) >= length(content(parser))

defn advance (parser: Parser) -> False:
  set-position(parser, position(parser) + 1)

defn add-entry (parser: Parser, key: String, value: TomlValue) -> False:
  insert(table(parser), key => value)

defn add-entry (parser: Parser, entry: TomlPair) -> False:
  insert(table(parser), key(entry) => value(entry))

defn skip-whitespace (parser: Parser) -> False:
  while peek(parser) == One(' '):
    advance(parser)

defn expect (parser: Parser, value: Char) -> False|Void:
  if peek(parser) == One(value):
    advance(parser)
  else:
    fatal("Expected: `%~`\nGot: `%~`" % [value, peek(parser)])

defn take-while (parser: Parser, pred: (Char -> True|False)) -> String:
  var ret = String("")
  var next: Maybe<Char> = None()
  defn* loop ():
    next = peek(parser)
    if next is-not None:
      val value = value!(next)
      if pred(value):
        ret = append(ret, to-string(value))
        advance(parser)
        loop()
    ret
  loop()

defn is-ascii (c: Char) -> True|False:
  ('a' <= c and c <= 'z') or
    ('A' <= c and c <= 'Z')

defn is-digit (c: Char) -> True|False:
  '0' <= c and c <= '9'

defn parse-string (parser: Parser) -> String:
  expect(parser, '"')

  val value = take-while(parser, {_ != '"'})
  expect(parser, '"')

  value

defn parse-integer (parser: Parser) -> Int:
  to-int!(take-while(parser, is-digit))

defn parse-table (parser: Parser) -> TomlPair:
  expect(parser, '[')
  val name = take-while(parser, is-ascii)
  if length(name) == 0:
    fatal("Expected table name, got: `%~`" % [peek(parser)])
  expect(parser, ']')

  val table = TomlTable()
  while peek(parser) != None():
    val kv = parse-key-value(parser)
    insert(table, key(kv) => value(kv))

  TomlPair(name, table)

defn parse-key-value (parser: Parser) -> TomlPair:
  skip-whitespace(parser)

  val key = take-while(parser, is-ascii)
  if length(key) == 0:
    fatal("Expected key, got: `%~`" % [peek(parser)])

  skip-whitespace(parser)
  expect(parser, '=')
  skip-whitespace(parser)

  val c = peek(parser)
  val value =
    if c == One('"'):
      parse-string(parser)
    else if c is-not None and is-digit(value!(c)):
      parse-integer(parser)
    else:
      fatal("Unexpected %~" % [c])

  if not (at-end(parser) or peek(parser) == One('\n')):
    fatal("Expected EOF or newline, got: %~" % [peek(parser)])

  advance(parser)

  TomlPair(key, value)

public defn parse-file (content: String) -> TomlFile:
  val parser = Parser(content, 0, TomlTable())
  while not at-end(parser) :
    if peek(parser) == One('['):
      add-entry(parser, parse-table(parser))
    else:
      add-entry(parser, parse-key-value(parser))
  TomlFile(table(parser))
